
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>二分查找与中序遍历与搜索树 | 嘟嘟噜の牧场</title>
    <meta name="author" content="嘟嘟噜~" />
    <meta name="description" content="" />
    <meta name="keywords" content="IT 算法 二次元" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.8/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/mark.png" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <i class="fa-solid fa-piggy-bank fa-bounce"></i>
            <span>&ensp;嘟嘟噜の牧场</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;嘟嘟噜の牧场</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>二分查找与中序遍历与搜索树</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/10/31
        </span>
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E5%88%86%E6%B2%BB/" style="color: #00a596">分治</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="二分查找与中序遍历与搜索树"><a href="#二分查找与中序遍历与搜索树" class="headerlink" title="二分查找与中序遍历与搜索树"></a>二分查找与中序遍历与搜索树</h1><h2 id="⭐二分查找"><a href="#⭐二分查找" class="headerlink" title="⭐二分查找"></a>⭐二分查找</h2><p><img src="/2023/10/31/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E6%90%9C%E7%B4%A2%E6%A0%91/1.png" alt="image-20231031235156177"></p>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>背过即可，有个移位操作</li>
<li>两种实现，递归实现注意自己设计好递归函数的参数，形成的是<strong>递归链</strong>，不再是<strong>递归树</strong></li>
<li>注意low和high<strong>只隔一位或者重合</strong>的情况讨论，有时会影响一些边界细节</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="c++">class Solution &#123;
public:
    int search(vector&lt;int&gt;&amp; nums, int target) &#123;
        int low = 0;
        int high = nums.size()-1;
        int mid;
        while (low &lt;= high)
        &#123;
            mid = low + ((high-low)&gt;&gt;1);
            if(nums[mid] == target) &#123;
                return mid;
            &#125;
            else if (nums[mid] &lt; target)
            &#123;
                low = mid + 1;
            &#125;else &#123;
                high = mid - 1;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;

// 2.递归
class Solution &#123;
public:
    int binsearch(vector&lt;int&gt;&amp; nums, int low, int high, int target) &#123;
        if(low &lt;= high) &#123;
            int mid = low + ((high-low)&gt;&gt;1);
            if(nums[mid] == target) &#123;
                return mid;
            &#125;
            else if (nums[mid] &lt; target)
            &#123;
                return binsearch(nums, mid + 1, high, target);
            &#125;else &#123;
                return binsearch(nums, low, mid - 1, target);
            &#125;
        &#125;
        return -1;
    &#125;

    int search(vector&lt;int&gt;&amp; nums, int target) &#123;
        return binsearch(nums, 0, nums.size()-1, target);
    &#125;
&#125;;
</code></pre>
<h2 id="山脉数组的峰顶索引"><a href="#山脉数组的峰顶索引" class="headerlink" title="山脉数组的峰顶索引"></a>山脉数组的峰顶索引</h2><p><img src="/2023/10/31/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E6%90%9C%E7%B4%A2%E6%A0%91/2.png" alt="image-20231101000102215"></p>
<h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>意识到这是一个查找问题，<strong>从数组里找到满足某一性质的元素</strong>，可以用二分思想。</li>
<li>注意low和high只隔一位或者重合的情况讨论，会有mid&#x3D;0或者mid&#x3D;size()-1的边界情况，所以可以直接让low从1开始，high从size-2开始。</li>
</ul>
<pre><code class="C++">class Solution &#123;
public:
    int peakIndexInMountainArray(vector&lt;int&gt;&amp; arr) &#123;
        int low = 1;
        int high = arr.size()-2;
        int mid;
        while (low &lt;= high)
        &#123;
            mid = low + ((high-low)&gt;&gt;1);
            // if(mid == 0) return mid + 1; //一种特殊情况，顶峰出在第二个元素位置
            if(arr[mid-1] &lt; arr[mid] &amp;&amp; arr[mid] &lt; arr[mid+1]) &#123;
                low = mid + 1;
            &#125;else if (arr[mid-1] &gt; arr[mid] &amp;&amp; arr[mid] &gt; arr[mid+1])
            &#123;
                high = mid - 1;
            &#125;else&#123;
                return mid;
            &#125;
            
        &#125;
        return -1;
    &#125;
&#125;;
</code></pre>
<h2 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h2><p><img src="/2023/10/31/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E6%90%9C%E7%B4%A2%E6%A0%91/3.png" alt="image-20231104221500375"></p>
<h3 id="关键点-2"><a href="#关键点-2" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>二叉搜索树可以在搜索时实现<strong>剪枝</strong>，搜索效率比普通树要高</li>
</ul>
<pre><code class="C++">class Solution &#123;
public:
    TreeNode* searchBST(TreeNode* root, int val) &#123;
        if(!root) return nullptr;
        if(root-&gt;val == val) return root;
        if(root-&gt;val &gt; val) return searchBST(root-&gt;left, val);
        else return searchBST(root-&gt;right, val);
    &#125;
&#125;;
</code></pre>
<h2 id="⭐验证二叉搜索树与二叉搜索树的最小绝对差"><a href="#⭐验证二叉搜索树与二叉搜索树的最小绝对差" class="headerlink" title="⭐验证二叉搜索树与二叉搜索树的最小绝对差"></a>⭐验证二叉搜索树与二叉搜索树的最小绝对差</h2><p><img src="/2023/10/31/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E6%90%9C%E7%B4%A2%E6%A0%91/4.png" alt="image-20231104222358767"></p>
<p><img src="/2023/10/31/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E6%90%9C%E7%B4%A2%E6%A0%91/6.png" alt="image-20231104223426166"></p>
<p><img src="/2023/10/31/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E6%90%9C%E7%B4%A2%E6%A0%91/5.jpg" alt="img"></p>
<h3 id="关键点-3"><a href="#关键点-3" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>使用<strong>前序遍历</strong>模板，借助&lt;a,b&gt;元组约束验证一棵树是否是二叉搜索树，原理是：对于二叉搜索树来说，走到某一结点的路径可以确定其约束元组。</li>
<li>使用<strong>中序遍历</strong>模板，将一棵二叉搜索树转换为一个递增序列，递归遍历过程中实时更新pre和ans的值，就可以得到最小绝对值差。</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="C++">class Solution &#123;
public:
    bool isValidBST(TreeNode* root) &#123;
        if(!root) return true;
        if((root-&gt;left&amp;&amp;root-&gt;left-&gt;val &gt;= root-&gt;val) || (root-&gt;right&amp;&amp;root-&gt;right-&gt;val &lt;= root-&gt;val)) return false;
        return isValidBST(root-&gt;left) &amp;&amp; isValidBST(root-&gt;right);
    &#125;
&#125;;

class Solution &#123;
public:
    bool helpler(TreeNode* root, long long low, long long high ) &#123;
        if(root == nullptr) &#123;
            return true;
        &#125;
        if(root-&gt;val &lt;= low || root-&gt;val &gt;= high) &#123;
            return false;
        &#125;
        return helpler(root-&gt;left, low, root-&gt;val) &amp;&amp; helpler(root-&gt;right, root-&gt;val, high);
    &#125;

    bool isValidBST(TreeNode* root) &#123;
        return helpler(root, LONG_MIN, LONG_MAX);
    &#125;
&#125;;
</code></pre>
<pre><code class="c++">class Solution &#123;
public:
    void dfs(TreeNode* root, int &amp;pre, int &amp;ans) &#123;
        if(!root) return;
        dfs(root-&gt;left, pre, ans);
        if(pre == -1) &#123;
            pre = root-&gt;val;
        &#125;else&#123;
            ans = min(ans, root-&gt;val-pre);
            pre = root-&gt;val;
        &#125;
        dfs(root-&gt;right, pre, ans);
    &#125;

    int getMinimumDifference(TreeNode* root) &#123;
        int ans = INT_MAX, pre = -1;
        dfs(root, pre, ans);
        return ans;
    &#125;
&#125;;
</code></pre>
<h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2><p><img src="/2023/10/31/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E6%90%9C%E7%B4%A2%E6%A0%91/7.png" alt="image-20231104223637509"></p>
<h3 id="关键点-4"><a href="#关键点-4" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>思路和找最小绝对值差一样，都是利用中序遍历将树转换为序列，然后在递归过程中保存全局的变量迭代更新，就是边界条件麻烦一点。</li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="c++">class Solution &#123;
public:
    void dfs(TreeNode* root, int &amp;pre, int &amp;cur_c, int &amp;max_c, vector&lt;int&gt; &amp;ans) &#123;
        if(!root) return;
        dfs(root-&gt;left, pre, cur_c, max_c, ans);
        if(pre == root-&gt;val) &#123;
            cur_c ++;
        &#125;else &#123; // 结算前一组相同的数，但得排除INT_MIN
            if(cur_c == max_c &amp;&amp; pre != INT_MIN) &#123;
                ans.push_back(pre);
            &#125;else if (cur_c &gt; max_c &amp;&amp; pre != INT_MIN)
            &#123;
                ans.clear(); 
                ans.push_back(pre);
                max_c = cur_c;
            &#125;
            pre = root-&gt;val;
            cur_c = 1; //来计算新的一组数
        &#125;
        dfs(root-&gt;right, pre, cur_c, max_c, ans);
    &#125;

    vector&lt;int&gt; findMode(TreeNode* root) &#123;
        int pre = INT_MIN;
        int max_c = 0;
        int cur_c = 0;
        vector&lt;int&gt; ans;
        dfs(root, pre, cur_c, max_c, ans);
        // 考虑最后一组数
        if(cur_c == max_c) &#123;
            ans.push_back(pre);
        &#125;
        if(cur_c &gt; max_c) &#123;
            ans.clear();
            ans.push_back(pre);
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
<h2 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h2><p><img src="/2023/10/31/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E6%90%9C%E7%B4%A2%E6%A0%91/8.png" alt="image-20231104233943320"></p>
<p><img src="/2023/10/31/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E6%90%9C%E7%B4%A2%E6%A0%91/9.jpg" alt="img"></p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="C++">class Solution &#123;
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;
    int left = 0;
    int right = nums.size() - 1;
    int first = -1;
    int last = -1;
    vector&lt;int&gt; ans;
    // 找第一个等于target的位置
    while (left &lt;= right) &#123;
      int middle = (left + right) / 2;
      if (nums[middle] == target) &#123;
        first = middle;
        right = middle - 1; //重点
      &#125; else if (nums[middle] &gt; target) &#123;
        right = middle - 1;
      &#125; else &#123;
        left = middle + 1;
      &#125;
    &#125;

    // 最后一个等于target的位置
    left = 0;
    right = nums.size() - 1;
    while (left &lt;= right) &#123;
      int middle = (left + right) / 2;
      if (nums[middle] == target) &#123;
        last = middle;
        left = middle + 1; //重点
      &#125; else if (nums[middle] &gt; target) &#123;
        right = middle - 1;
      &#125; else &#123;
        left = middle + 1;
      &#125;
    &#125;
    return ans = &#123;first, last&#125;;
&#125;
&#125;;
</code></pre>
<h2 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h2><p><img src="/2023/10/31/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E6%90%9C%E7%B4%A2%E6%A0%91/10.png" alt="image-20231109171308745"></p>
<h3 id="关键点-5"><a href="#关键点-5" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>其实对于有序数列来说随便一个点提起来都是一棵二叉搜索树，但是如果要满足<strong>高度平衡</strong>的条件，就需要不断用二分查找确定根节点</li>
<li>然后不断递归实现即可</li>
</ul>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre><code class="C++">class Solution &#123;
public:
    TreeNode* helpler(vector&lt;int&gt;&amp; nums, int low, int high) &#123;
        if(low &gt; high) return nullptr;
        int mid = (low + high) &gt;&gt; 1;
        TreeNode* node = new TreeNode(nums[mid]);
        node-&gt;left = helpler(nums, low, mid - 1);
        node-&gt;right = helpler(nums, mid + 1, high);
        return node;
    &#125;

    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;
        int low = 0;
        int high = nums.size()-1;
        return helpler(nums, low, high);
    &#125;
&#125;;
</code></pre>
<h2 id="爱吃香蕉的珂珂"><a href="#爱吃香蕉的珂珂" class="headerlink" title="爱吃香蕉的珂珂"></a>爱吃香蕉的珂珂</h2><p><img src="/2023/10/31/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E6%90%9C%E7%B4%A2%E6%A0%91/11.png" alt="image-20231109172301616"></p>
<h3 id="关键点-6"><a href="#关键点-6" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li><p>有临界性质（最大最小）的问题，就可以考虑用二分查找！需要确定有：</p>
<ul>
<li>查找出口</li>
<li>low和high端点，这里我用了放缩确定</li>
<li>mid落入左右分区时，low和high的移动逻辑</li>
</ul>
</li>
<li><p>注意<strong>向上取整</strong>的实现方法，(x+d-1)&#x2F;d。</p>
</li>
<li><p>vector中**begin(),end(),rbegin(),rend()**的用法。</p>
</li>
</ul>
<pre><code class="C++">sort(piles.begin(), piles.end()); //从小到大
sort(piles.rbegin(), piles.rend()); //从大到小
</code></pre>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre><code class="C++">class Solution &#123;
public:
    long long sumTime(vector&lt;int&gt; piles, long long k) &#123;
        long long n = piles.size();
        long long sum = 0;
        for (long long i = 0; i &lt; n; i++)
        &#123;
            sum += (piles[i] + k - 1) / k;
        &#125;
        return sum;
    &#125;

    int minEatingSpeed(vector&lt;int&gt;&amp; piles, int h) &#123;
        long long c = piles.size();
        sort(piles.begin(), piles.end());
        long long min_p = piles.front();
        long long max_p = piles.back();
        long long low_k = (c*min_p + h - 1) / h;
        long long high_k = max_p;
        long long mid;
        
        while (low_k &lt;= high_k)
        &#123;
            mid = low_k +((high_k - low_k) &gt;&gt; 1);
            long long fuck = sumTime(piles, mid); 
            if(mid == 1 &amp;&amp; fuck &lt;= h) return 1; //经典边界
            // 有临界性质（最大最小）的问题，就可以考虑用二分查找
            if(fuck &lt;= h &amp;&amp; sumTime(piles, mid-1) &gt; h) &#123;
                return mid;
            &#125;else if (fuck &gt; h)
            &#123;
                low_k = mid + 1;
            &#125;else&#123;
                high_k = mid - 1;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2023 - 2023 嘟嘟噜の牧场
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;嘟嘟噜~
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
	<div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
    </div>
    <script src="/js/main.js"></script>
	<style>
	.text::after{
            content: '';
            position: absolute;
            right: -10px;
            top: 5px;
            height: 20px;
            width: 3px;     
            background-color: #1e3e3f;
            animation: san 0.5s steps(1) infinite;
        }
        @keyframes san{
            0%,100%{
                background-color: #1e3e3f;
            }
            50%{
               background-color: transparent;
            }

        }
	</style>
    <script>
	var text = document.querySelector('.text');
	const txt  =["Here's a dudulu..."]; 
	var index=0;
	var xiaBiao= 0;
	var huan = true;
	setInterval(function(){
		if(huan){             
			text.textContent = txt[xiaBiao].slice(0,++index);
		}
		else{
			text.textContent = txt[xiaBiao].slice(0,index--);
		}
		
		if(index==txt[xiaBiao].length+3)
		{
			huan = false;
		}
		else if(index<0)
		{   
			index = 0;
			huan = true;
			xiaBiao++;
			if(xiaBiao>=txt.length)
			{   
				xiaBiao=0; 
			}
		}
	},200)
	</script>
	<script type="text/javascript"
		color="150,150,150" opacity='1' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
	</script>
	<style>
	.back-to-top {
	  right: 60px;
	  width: 70px;  //图片素材宽度
	  height: 900px;  //图片素材高度
	  top: -900px;
	  bottom: unset;
	  transition: all .5s ease-in-out;
	  background: url("/images/scroll.png");

	  //隐藏箭头图标
	  > i {
		display: none;
	  }

	  &.back-to-top-on {
		bottom: unset;
		top: 100vh < (900px + 200px) ? calc( 100vh - 900px - 200px ) : 0px;
	  }
	}
	</style>
    
    




    
</body>
</html>
