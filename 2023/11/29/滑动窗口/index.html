
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>滑动窗口-map | 嘟嘟噜の牧场</title>
    <meta name="author" content="嘟嘟噜~" />
    <meta name="description" content="" />
    <meta name="keywords" content="IT 算法 二次元" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.8/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/mark.png" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <i class="fa-solid fa-piggy-bank fa-bounce"></i>
            <span>&ensp;嘟嘟噜の牧场</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;嘟嘟噜の牧场</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>滑动窗口-map</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/11/29
        </span>
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" style="color: #ffa2c4">滑动窗口</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="滑动窗口-map"><a href="#滑动窗口-map" class="headerlink" title="滑动窗口+map"></a>滑动窗口+map</h1><p><img src="/2023/11/29/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/5.png" alt="image-20231129173228524"></p>
<blockquote>
<p>Leecode 340 至多包含 K 个不同字符的最长子串</p>
<p>Leecode 1004 最大连续1的个数 III </p>
<p>Leecode 1208 尽可能使字符串相等 </p>
<p>Leecode 1493 删掉一个元素以后全为 1 的最长子数组 </p>
<p>Leecode 3 无重复字符的最长子串 30. 串联所有单词的子串] </p>
<p>Leecode 76 最小覆盖子串 [159. 至多包含两个不同字符的最长子串] </p>
<p>Leecode 209 长度最小的子数组  </p>
<p>Leecode 438 找到字符串中所有字母异位词 </p>
<p>Leeocde 567 字符串的排列 [632. 最小区间] [727. 最小窗口子序列]</p>
</blockquote>
<h2 id="子数组的最大平均数"><a href="#子数组的最大平均数" class="headerlink" title="子数组的最大平均数"></a>子数组的最大平均数</h2><p><img src="/2023/11/29/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/1.png" alt="image-20231129215455248"></p>
<ul>
<li><p>简单的固定窗口，但注意减少冗余计算。</p>
</li>
<li><p>#include <algorithm> 里的max&#x2F;min可以用来更新迭代最值。</algorithm></p>
</li>
<li><p>? :语句也可以 </p>
<pre><code class="C++">if(y &lt; 10)&#123; 
   var = 30;
&#125;else&#123;
   var = 40;
&#125;
//上面的代码可以写成以下语句：
var = (y &lt; 10) ? 30 : 40;
</code></pre>
</li>
</ul>
<pre><code class="c++">class Solution &#123;
public:
    double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) &#123;
        int sum = 0;
        for (int i = 0; i &lt; k; i++)
        &#123;
            sum += nums[i];
        &#125;
        int Max = sum;
        for (int i = k; i &lt; nums.size(); i++)
        &#123;
            sum = sum - nums[i-k] + nums[i];
            Max = max(Max, sum);
        &#125;
        return (double)Max / k;
    &#125;
&#125;;
</code></pre>
<h2 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a>最长连续递增序列</h2><p><img src="/2023/11/29/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/2.png" alt="image-20231129220751996"></p>
<ul>
<li>抽缩型滑动，left直接缩到right前面。</li>
<li>思路很简单，但要注意<strong>边界细节</strong>：入循环，出循环的设计，序列访问开始和结束的设计。</li>
</ul>
<pre><code class="C++">class Solution &#123;
public:
    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;
        int n = nums.size();
        int cur = 0;
        int pre;
        int temp = 1;
        int Max = temp;
        // 抽缩型滑动，left直接缩到right前面
        while (cur &lt; n)
        &#123;   
            temp = 1;
            if(cur == n-1) break;
            pre = cur; // 开始前探
            while (pre &lt; n-1 &amp;&amp; nums[pre] &lt; nums[pre + 1]) // 出此循环有两种情况
            &#123;
                pre = pre + 1;
                temp ++;
            &#125;
            if(temp &gt; Max) Max = temp;
            cur = pre + 1;
        &#125;
        return Max;
    &#125;
&#125;;
</code></pre>
<h2 id="⭐3-无重复字符的最长字串"><a href="#⭐3-无重复字符的最长字串" class="headerlink" title="⭐3-无重复字符的最长字串"></a>⭐3-无重复字符的最长字串</h2><p><img src="/2023/11/29/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/3.png" alt="image-20231213143309843"></p>
<ul>
<li>这个题考虑用<unordered_map>实现一个hashmap来记忆【走过的字符对应的最新位置】：&lt;char, int&gt;。</unordered_map></li>
<li>窗口也是抽缩式滑动，只需要一个循环让right走到最右边即可，left每次循环里使用hashmap映射移动，无需再来一个循环。</li>
<li>但由于<strong>hashmap没有设计erase掉出窗口的键值对的机制</strong>，所以发生哈希碰撞时可能映射到比left更左边的位置，需要做判断。（后面的例子里有erase，可以对比）</li>
</ul>
<pre><code class="C++">class Solution &#123;
public:
    int lengthOfLongestSubstring(string s) &#123;
        if (s.empty()) return 0;
        unordered_map&lt;char, int&gt; map;
        int left = 0;
        int Max = 0;
        // 抽缩式滑动
        for (int right = 0; right &lt; s.length(); right ++) // 以每次移动right为粒度处理，进出边界
        &#123;
            if(map.count(s[right]) &gt; 0) &#123;
                left = max(left, map[s[right]] + 1); // 懒得erase掉不在窗口内的元素就会这样
            &#125;
            map[s[right]] = right; // 有就更新最新位置，没有就新建
            Max = max(Max, right - left + 1);
        &#125;
        return Max;
    &#125;
&#125;;
</code></pre>
<h2 id="159-至多包含两个不同字符的最长字串"><a href="#159-至多包含两个不同字符的最长字串" class="headerlink" title="159-至多包含两个不同字符的最长字串"></a>159-至多包含两个不同字符的最长字串</h2><p><img src="/2023/11/29/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/4.png" alt="image-20231213150640846"></p>
<ul>
<li>依然是使用hashmap，但最多记录两个键值对&lt;char, int&gt;，记录char出现过的最新位置。</li>
<li>添加到第三个时需要移除erase两个存着的键值对里位置靠后的一个，left移动到删除位置+1的地方。</li>
<li>依然是抽缩式前进，一个循环right往右走，left根据实际情况缩到合适的位置。</li>
</ul>
<p><img src="/2023/11/29/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/6.png" alt="image-20231213151419079"></p>
<h2 id="关于map和unordered-map容器"><a href="#关于map和unordered-map容器" class="headerlink" title="关于map和unordered_map容器"></a>关于map和unordered_map容器</h2><p>unordered_map（Hash） 容器和 map (红黑树) 容器一样，以键值对（pair类型）的形式存储数据，存储的各个键值对的<strong>键互不相同</strong>且不允许被修改。<strong>unordered_map插入和搜索元素的平均复杂度为 O(constant)，在不关心容器内部元素顺序时，能够获得显著的性能提升。</strong></p>
<h3 id="unordered-map用于实现哈希表"><a href="#unordered-map用于实现哈希表" class="headerlink" title="unordered_map用于实现哈希表"></a>unordered_map用于实现哈希表</h3><table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个键值对的正向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器中最后一个键值对之后位置的正向迭代器。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前容器中存有键值对的个数。</td>
</tr>
<tr>
<td>at(key)</td>
<td>返回容器中存储的键 key 对应的值，如果 key 不存在，则会抛出 out_of_range 异常。 &#x2F;&#x2F; 直接map[‘key’]就好</td>
</tr>
<tr>
<td>find(key)</td>
<td>查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的<strong>正向迭代器</strong>；反之，则返回一个<strong>指向容器中最后一个键值对之后位置的迭代器</strong>（end() 方法返回的迭代器）。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在容器中查找以 key 键的键值对的个数。 &#x2F;&#x2F;其实就是0和1，一般用来判断容器里有无该key</td>
</tr>
<tr>
<td>emplace()</td>
<td>向容器中添加新键值对，效率比 insert() 方法高。 &#x2F;&#x2F; 可直接向该方法传递创建新键值对所需要的 2 个元素的值，其中第一个元素将作为键值对的键，另一个作为键值对的值。也就是说，**该方法无需我们手动创建键值对，其内部会自行完成此工作。 **(返回值挺奇怪，不用接收)</td>
</tr>
<tr>
<td><del>insert()</del></td>
<td><del>向容器中添加新键值对。 &#x2F;&#x2F; 插入pair</del></td>
</tr>
<tr>
<td>erase()</td>
<td>删除指定键值对。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空容器，即删除容器中存储的所有键值对。</td>
</tr>
</tbody></table>
<h4 id="通过迭代器访问元素"><a href="#通过迭代器访问元素" class="headerlink" title="通过迭代器访问元素"></a>通过迭代器访问元素</h4><p>map&#x2F;unordered_map可以使用it-&gt;first来访问键，使用it-&gt;second访问值。</p>
<p>unordered_map 容器迭代器的类型为前向迭代器（又称<strong>正向迭代器</strong>）。这意味着，假设 p 是一个前向迭代器，则其只能进行 *p、p++、++p 操作，且 2 个前向迭代器之间只能用 &#x3D;&#x3D; 和 !&#x3D; 运算符做比较。</p>
<pre><code class="C++">#include&lt;map&gt;
#include&lt;iostream&gt;
using namespace std;
int main()
&#123;
   map&lt;char,int&gt;maps;
   maps[&#39;d&#39;]=10;
   maps[&#39;e&#39;]=20;
   maps[&#39;a&#39;]=30;
   maps[&#39;b&#39;]=40;
   maps[&#39;c&#39;]=50;
   maps[&#39;r&#39;]=60;
   for(map&lt;char,int&gt;::iterator it=mp.begin();it!=mp.end();it++)
   &#123;
       cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;
   &#125;
   return 0;
&#125;
</code></pre>
<pre><code class="C++">    //遍历输出 umap 容器中所有的键值对
    for (auto iter = umap.begin(); iter != umap.end(); ++iter) &#123;
        cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; iter-&gt;first &lt;&lt; &quot;, &quot; &lt;&lt; iter-&gt;second &lt;&lt; &quot;&gt;&quot; &lt;&lt; endl;
    &#125;
    //获取指向指定键值对的前向迭代器
    unordered_map&lt;string, string&gt;::iterator iter = umap.find(&quot;Java教程&quot;);
</code></pre>
<h4 id="erase"><a href="#erase" class="headerlink" title="erase()"></a>erase()</h4><ul>
<li><strong>迭代器擦除</strong>：unordered_map.erase(const iterator);</li>
<li><strong>按键擦除</strong>：unordered_map.erase(const key);</li>
</ul>
<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209-长度最小的子数组"></a>209-长度最小的子数组</h2><p><img src="/2023/11/29/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/7.png" alt="image-20231213230103032"></p>
<ul>
<li>还是抽缩式滑动，但需要套两层循环来移动left，区别于map直接映射left。</li>
</ul>
<pre><code class="c++">class Solution &#123;
public:
    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;
        int sum = 0;
        int left = 0;
        int right = 0;
        int Min = INT_MAX;
        while (right &lt; nums.size())
        &#123;
            sum += nums[right];
            while (sum &gt;= target)
            &#123;
                sum -= nums[left];
                Min = min(Min, right - left + 1);
                left ++;
            &#125;
            right ++;
        &#125;
        return Min == INT_MAX ? 0 : Min;
    &#125;
&#125;;
</code></pre>
<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1-两数之和"></a>1-两数之和</h2><p><img src="/2023/11/29/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/Users\19263\Desktop\dudulu_blog\source_posts\滑动窗口\image-20231229170900687.png" alt="image-20231229170900687"></p>
<ul>
<li>解法一：哈希表，边走边记，每遍历一个新数就查哈希表里是不是有target-nums[i]。</li>
<li>解法二：双指针。不管三七二十一，遍历就直接两头开双指针，就能从N降到logN。</li>
</ul>
<pre><code class="C++">// 1.哈希解法
class Solution &#123;
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;
        unordered_map&lt;int,int&gt; hash;
        for(int i = 0;i &lt; nums.size();i++)
        &#123;
           auto it = hash.find(target - nums[i]);
           if(it != hash.end())
           &#123;
               return &#123;it-&gt;second,i&#125;;
           &#125;
           hash.emplace(nums[i],i); 
        &#125;
        return &#123;&#125;;
    &#125;
&#125;;

// 2.双指针解法
class Solution &#123;
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;
        if(nums.size() &lt; 2) return &#123;&#125;;
        int t;
        // int i;
        int j;
        int k;
        for (int i = 0; i &lt; nums.size() - 1; i++)
        &#123;
            t = target - nums[i];
            for (j = i + 1, k = nums.size() - 1; j &lt;= k; j++, k--)
            &#123;
                if(nums[j] == t) &#123;
                    return &#123;i, j&#125;;
                &#125;
                if(nums[k] == t) &#123;
                    return &#123;i, k&#125;;
                &#125;
            &#125;
        &#125;
        return &#123;&#125;;
    &#125;
&#125;;
</code></pre>
<h2 id="⭐15-三数之和"><a href="#⭐15-三数之和" class="headerlink" title="⭐15-三数之和"></a>⭐15-三数之和</h2><p><img src="/2023/11/29/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/Users\19263\Desktop\dudulu_blog\source_posts\滑动窗口\image-20231229171723770.png" alt="image-20231229171723770"></p>
<p><img src="/2023/11/29/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/Users\19263\Desktop\dudulu_blog\source_posts\滑动窗口\image-20231229171748206.png" alt="image-20231229171748206"></p>
<ul>
<li><p>相比两数之和，这个题不仅要多考虑一个数，还要考虑结果组合的<strong>去重</strong>，还要输出<strong>所有</strong>的符合条件的三个数，就麻烦了很多。</p>
</li>
<li><p>核心思路就是<strong>排序+双指针</strong>。排序是个很讨巧的做法，虽然直接上了NlogN的复杂度，但这个问题肉眼可见复杂度只会比NlogN高，所以不差先做个排序。</p>
</li>
<li><p>排序后，按从小到大的顺序依次确定a b c，就可以<strong>去重组合</strong>。同时也使得我们可以使用双指针，定住一个a后，b从a+1位置一直往右移，c从尾部一直往左移，b移动一次c会移动若干次，<strong>c每次从a+b+c&gt;t到a+b+c&lt;&#x3D;t的临界时再移动b,b和c相撞后移动a</strong>。时间复杂度就来到了N2。</p>
</li>
</ul>
<pre><code class="C++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;
        int len = nums.size();
        vector&lt;vector&lt;int&gt;&gt; ans;
        if(len &lt; 3) return ans;
        sort(nums.begin(), nums.end());
        int a;
        int b;
        int c;
        for (a = 0; a &lt; len - 1; a++)
        &#123;   
            if(a &gt; 0 &amp;&amp; nums[a] == nums[a-1]) continue;
            c = len - 1;
            for (b = a + 1; b &lt; c; b++)
            &#123;
                // 新a带出的新b可以一样
                if(b &gt; 0 &amp;&amp; nums[b] == nums[b-1] &amp;&amp; b - 1 != a) continue;
                // 来到了新的b值
                while (nums[a] + nums[b] + nums[c] &gt; 0 &amp;&amp; b &lt; c)
                &#123;   
                    c --;
                &#125;
                if(b == c) break; // bc相撞移动a
                if(nums[a] + nums[b] + nums[c] == 0) &#123; // 检查是否是一个解
                    vector&lt;int&gt; res = &#123;nums[a],nums[b],nums[c]&#125;;
                    ans.push_back(res);
                    c --;
                    while (c &gt; 0 &amp;&amp; nums[c+1] == nums[c]) // 当下c值已经用了,c变小到新值
                    &#123;
                        c --;
                    &#125;
                &#125;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2023 - 2024 嘟嘟噜の牧场
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;嘟嘟噜~
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
	<div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
    </div>
    <script src="/js/main.js"></script>
	<style>
	.text::after{
            content: '';
            position: absolute;
            right: -10px;
            top: 5px;
            height: 20px;
            width: 3px;     
            background-color: #1e3e3f;
            animation: san 0.5s steps(1) infinite;
        }
        @keyframes san{
            0%,100%{
                background-color: #1e3e3f;
            }
            50%{
               background-color: transparent;
            }

        }
	</style>
    <script>
	var text = document.querySelector('.text');
	const txt  =["Here's a dudulu..."]; 
	var index=0;
	var xiaBiao= 0;
	var huan = true;
	setInterval(function(){
		if(huan){             
			text.textContent = txt[xiaBiao].slice(0,++index);
		}
		else{
			text.textContent = txt[xiaBiao].slice(0,index--);
		}
		
		if(index==txt[xiaBiao].length+3)
		{
			huan = false;
		}
		else if(index<0)
		{   
			index = 0;
			huan = true;
			xiaBiao++;
			if(xiaBiao>=txt.length)
			{   
				xiaBiao=0; 
			}
		}
	},200)
	</script>
	<script type="text/javascript"
		color="150,150,150" opacity='1' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
	</script>
	<style>
	.back-to-top {
	  right: 60px;
	  width: 70px;  //图片素材宽度
	  height: 900px;  //图片素材高度
	  top: -900px;
	  bottom: unset;
	  transition: all .5s ease-in-out;
	  background: url("/images/scroll.png");

	  //隐藏箭头图标
	  > i {
		display: none;
	  }

	  &.back-to-top-on {
		bottom: unset;
		top: 100vh < (900px + 200px) ? calc( 100vh - 900px - 200px ) : 0px;
	  }
	}
	</style>
    
    




    
</body>
</html>
